思路：每次在一个数组中找到一个基准，将比之小的移到左边的数组，大的放到右边的数组。递归调用直至每个数组只剩下一个元素。

	const quick_sort = arr=> {
	    if (arr.length <= 1) return arr;
	    let pivotIndex = ~~(arr.length/2),
	        pivot = arr.splice(pivotIndex,1)[0],       //这个地方要注意将pivot移出
	        left = [],
	        right = [];
	    for (let i = 0; i < arr.length; i++) { //length 导致栈溢出！？
	        if (arr[i] < pivot) {
	            left.push(arr[i]);
	        }else{
	            right.push(arr[i])
	        }
	    }
	    return quick_sort(left).concat(pivot, quick_sort(right));
	}

原地排序：不申请多余空间来进行排序，即只在原数组数据中比较和交换的排序。

上面每次递归都申请了两个数组空间，为非原地排序。

----

*2017/7/18 23:17*:

昨天晚上刚写完，面试就问到了、、写完之后面试官还问有没有其他写法。

    const partition = (arr, low, high) => {
        //最初将数组的第一位设置为标杆，在每一次执行中最终将比标杆小的移到左边，大的移到右边，并返回标杆在数组中的正确的下标。
        let pivot = arr[low];
        while(low < high){	// 如果不考虑arr[low] == arr[high] 的情况将陷入死循环
            while(low < high && arr[high] >= pivot){
                high--;
            }
            arr[low] = arr[high];
            while(low < high && arr[low] < pivot){
                low++;
            }
            arr[high] = arr[low];
        }
        arr[low] = pivot;
        return low;
    }

    const quickSort = (arr, left, right) => {
        if(left < right) {
            let pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex-1);
            quickSort(arr, pivotIndex+1, right)
        }
    }
    let arr = [1,3,5,45,53,43,4325,4,4234,6,213,4,6,3,2,19];
    quickSort(arr);
