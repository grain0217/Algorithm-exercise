给你两个单词`word1`和`word2`，请你计算出将`word1`转换成`word2`所使用的最少操作数 。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**
```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**
```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

### 动态规划
我们可以对任意一个单词进行三种操作：
- 插入一个字符；
- 删除一个字符；
- 替换一个字符。

题目给定了两个单词，设为`A`和`B`，这样我们就能够六种操作方法。

但我们可以发现，如果我们有单词`A`和单词`B`：
1. 对单词`A`删除一个字符和对单词`B`插入一个字符是等价的。例如当单词`A`为`doge`，单词`B`为`dog`时：
- 我们既可以删除单词`A`的最后一个字符`e`，得到相同的`dog`
- 也可以在单词`B`末尾添加一个字符`e`，得到相同的`doge`
2. 同理，对单词`B`删除一个字符和对单词`A`插入一个字符也是等价的；
3. 对单词`A`替换一个字符和对单词`B`替换一个字符是等价的。例如当单词`A`为`bat`，单词`B`为`cat`时，我们修改单词`A`的第一个字母`b -> c`，和修改单词`B`的第一个字母 `c -> b`是等价的。

这样一来，本质不同的操作实际上只有三种：
- 在单词`A`中插入一个字符；
- 在单词`B`中插入一个字符；
- 修改单词`A`的一个字符。

如此一来，我们就可以把原问题转化为规模较小的子问题。我们用`A = horse，B = ros`作为例子：

- 在单词`A`中插入一个字符：如果我们知道`horse`到`ro`的编辑距离为`a`，那么显然`horse`到`ros`的编辑距离不会超过`a + 1`。这是因为我们可以在`a`次操作后将`horse`和`ro`变为相同的字符串，只需要额外的`1`次操作，在单词`A`的末尾添加字符`s`，就能在`a + 1`次操作后将`horse`和`ro`变为相同的字符串；
- 在单词`B`中插入一个字符：如果我们知道`hors`到`ros`的编辑距离为`b`，那么显然`horse`到`ros`的编辑距离不会超过`b + 1`，原因同上；
- 修改单词`A`的一个字符：如果我们知道`hors`到`ro`的编辑距离为`c`，那么显然`horse`到`ros`的编辑距离不会超过`c + 1`，原因同上。

那么从`horse`变成`ros`的编辑距离应该为`min(a + 1, b + 1, c + 1)`。

**注意**：为什么我们总是在单词`A`和`B`的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词`cat`，我们希望在`c`和`a`之间添加字符`d`并且将字符`t`修改为字符`b`，那么这两个操作无论为什么顺序，都会得到最终的结果`cdab`。

你可能觉得`horse`到`ro`这个问题也很难解决。但是没关系，我们可以继续用上面的方法拆分这个问题，对于这个问题拆分出来的所有子问题，我们也可以继续拆分，直到：
- 字符串`A`为空，如从空转换到`ro`，显然编辑距离为字符串`B`的长度，这里是`2`；
- 字符串`B`为空，如从`horse`转换到 ，显然编辑距离为字符串`A`的长度，这里是`5`。

因此，我们就可以使用动态规划来解决这个问题了。我们用`dp[i][j]`表示`A`的前`i`个字母和`B`的前`j`个字母之间的编辑距离：
```js
dp[i][j] = A[i] === B[j] ? dp[i - 1][j - 1] : 1 + Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])
```

代码：
```js
function minDistance (word1, word2) {
  const m = word1.length
  const n = word2.length
  const dp = []
  if (m * n === 0) return m + n
  for (let i = 0; i <= m; i++) {
    dp[i] = []
    for (let j = 0; j <= n; j++) {
      if (i === 0) {
        dp[i][j] = j
      } else if (j === 0) {
        dp[i][j] = i
      } else if (word1.charAt(i - 1) === word2.charAt(j - 1)) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        // dp[i][j - 1] word1[i]后插入word2[j]
        // dp[i - 1][j] 删除word1[i]
        // dp[i - 1][j - 1] word1[i]替换为word2[j]
        dp[i][j] = 1 + Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])
      }
    }
  }
  return dp[m][n]
}
```

出口在当其中一个为空串，返回另一个字符串的长度，因此状态的定义`dp[i][j]`为`A`的前`i`个字母和`B`的前`j`个字母的编辑距离。
