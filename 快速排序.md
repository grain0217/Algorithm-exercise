思路：每次在一个数组中找到一个基准，将比之小的移到左边的数组，大的放到右边的数组。递归调用直至每个数组只剩下一个元素。

	const quick_sort = arr=> {
	    if (arr.length <= 1) return arr;
	    let pivotIndex = ~~(arr.length/2),
	        pivot = arr.splice(pivotIndex,1)[0],       //这个地方要注意将pivot移出
	        left = [],
	        right = [];
	    for (let i = 0; i < arr.length; i++) { //length 导致栈溢出！？
	        if (arr[i] < pivot) {
	            left.push(arr[i]);
	        }else{
	            right.push(arr[i])
	        }
	    }
	    return quick_sort(left).concat(pivot, quick_sort(right));
	}

原地排序：不申请多余空间来进行排序，即只在原数组数据中比较和交换的排序。

上面每次递归都申请了两个数组空间，为非原地排序。

----

*2017/7/18 23:17*:

昨天晚上刚写完，面试就问到了、、写完之后面试官还问有没有其他写法。

function quickSort(arr) {
    // 交换
    function swap(arr, a, b) {
        var temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    // 分区
    const partition = (arr, left, right) => {
        /**
         * 开始时不知最终pivot的存放位置，可以先将pivot交换到后面去
         * 这里直接定义最右边的元素为基准
         */
        let pivot = arr[right],
        /**
         * 存放小于pivot的元素时，是紧挨着上一元素的，否则空隙里存放的可能是大于pivot的元素，
         * 故声明一个storeIndex变量，并初始化为left来依次紧挨着存放小于pivot的元素。
         */
            storeIndex = left;
        for (let i = left; i < right; i++) {
            if (arr[i] < pivot) {
                /**
                 * 遍历数组，找到小于的pivot的元素，（大于pivot的元素会跳过）
                 * 将循环i次时得到的元素，通过swap交换放到storeIndex处，
                 * 并对storeIndex递增1，表示下一个可能要交换的位置
                 */
                swap(arr, storeIndex, i);
                storeIndex++;
            }
        }
        // 最后： 将pivot交换到storeIndex处，基准元素放置到最终正确位置上
        swap(arr, right, storeIndex);
        return storeIndex;
    }

    const sort = (arr, left, right) => {
        if (left > right) return;

        let storeIndex = partition(arr, left, right);
        sort(arr, left, storeIndex - 1);
        sort(arr, storeIndex + 1, right);
    }

    sort(arr, 0, arr.length - 1);
    return arr;
}
